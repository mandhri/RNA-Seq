---
title: "RNA-Seq_differential_expression_analysis"
output: html_document
date: "2025-04-18"
---

```{r,packages}


suppressPackageStartupMessages({
  library("EnhancedVolcano")
  library("limma")
  library("tximport")
  library("apeglm")
  library("eulerr")
library("DESeq2")
  library("HGNChelper")
  library("tictoc")
  library("DESeq2")
  library("kableExtra")
  library("beeswarm")
  library("missMethyl")
  library("gridExtra")
  library("png")
  library("metafor")
  library("ggplot2")
  library("purrr")
library("metafor")
library("dplyr")
library("readxl")
library("ggplot2")
library("tidyverse")
library("magrittr")
library("readr")
library("eulerr")
library("RColorBrewer")
library("e1071")
  library("plotly") 
  library("pheatmap")

})

CORES=16

```
# Read the sample manifest and alignment summary

# Confirm all your pseudo-alignment rates are comfortably high (> ~90%).

```{r}
samples <- read_tsv("/mnt/vol1/RNA-Seq/kallisto_tutorial/results/samples.txt", col_types = cols())
samples

align <- read_tsv("/mnt/vol1/RNA-Seq/kallisto_tutorial/results/alignment_summary.tsv")
align %>% 
  dplyr::arrange(align$`Rate(%)`) %>% 
  print(n=10)

```

# Import transcripts to gene level via trimport package

```{r fig.width=11, fig.height=9, message=FALSE, warning=FALSE, echo=TRUE}

tx2gene <- read_tsv("/mnt/vol1/RNA-Seq/kallisto_tutorial/results/tx2gene.tsv",
                    col_names = c("TXNAME","GENEID"),
                    col_types = cols(
                      TXNAME = col_character(),
                      GENEID = col_character()
                    ))

head(tx2gene)

files <- samples$path
names(files) <- samples$sample

txi <- tximport(files    = files,
                type     = "kallisto",
                tx2gene  = tx2gene,
                ignoreTxVersion = TRUE)

# Inspect the components:
names(txi)

```

# Reading meta data that comes with the samples

```{r fig.width=11, fig.height=9, message=FALSE, warning=FALSE, echo=TRUE}

pheno<-read_delim("/mnt/vol1/RNA-Seq/SraRunTable.csv")
coldata <- pheno %>%
  select(sample = Run, condition = treatment) 

coldata <- coldata %>%
  mutate(condition = dplyr::recode(condition, 
                            "None" = "Control", 
                            "7day_UUO" = "Treated"))

samples <- left_join(samples, coldata, by = "sample")

```

# Making DESeqDataSet from tximport

```{r fig.width=11, fig.height=9, message=FALSE, warning=FALSE, echo=TRUE}

all(samples$sample == colnames(txi$counts))
samples <- samples[match(colnames(txi$counts), samples$sample), ]
head(samples)

metadata <- samples %>%
  column_to_rownames("sample") %>%
  select(condition)
head(metadata)

dds <- DESeqDataSetFromTximport(txi,
                                colData = metadata,
                                design  = ~ condition)
str(dds)

```


# Filtering for low count and normalisation

## Now that we have our DESeq2 object created with the raw counts and metadata stored inside, we can start the DESeq2 workflow. The first step in the workflow is to normalise the raw counts to assess sample-level quality control metrics.

## But what does it mean to normalise the raw counts? The raw counts represent the number of reads aligning to each gene and should be proportional to the expression of the RNA in the sample; however, there are factors other than RNA expression that can influence the number of reads aligning to each gene. We can adjust the count data to remove the influence of these factors on the overall counts using normalisation methods. The main factors often considered during normalisation of count data are library depth, gene length, and RNA composition.

## Differences in library size between samples can lead to many more reads being aligned to genes in one sample versus another sample. Another normalisation factor often adjusted for is gene length. A longer gene generates a longer transcript, which generates more fragments for sequencing. Therefore, a longer gene will often have more counts than a shorter gene with the same level of expression. If the DE analysis compares expression levels of the same genes between conditions, we do not need to normalise for gene length. However, if you were to compare the expression levels of different genes, you would need to account for lengths of the genes. For example In differential expression (DE) analysis:When comparing the expression of Gene A between Condition 1 and Condition 2, Gene A maintains the same physical length in both conditions. Since longer genes naturally attract more sequencing reads simply due to their increased target size, this length bias affects Gene A equally in both conditions. Therefore, when the ratio between conditions is calculated, the length bias cancels out mathematically, making gene length normalisation unnecessary.When comparing different genes: If comparing Gene A (1,000 base pairs) to Gene B (5,000 base pairs) within the same sample, Gene B will typically receive approximately five times more reads than Gene A, even if both genes are expressed at identical levels. This occurs because Gene B presents a larger target for random fragmentation and sequencing. Without length normalisation, Gene B would appear falsely more highly expressed.

## When adjusting for library size, the composition of the library is also important. A few highly differentially expressed genes can skew many normalisation methods that are not resistant to these outliers. If we just divided our counts by the total number of reads, normalisation for the majority of genes would be skewed by the highly expressed DE gene. For this reason, when performing a DE analysis, we need to use a method that is resistant to these outlier genes.

```{r fig.width=11, fig.height=9, message=FALSE, warning=FALSE, echo=TRUE}

keep <- rowSums(counts(dds)) >= 10
dds  <- dds[keep, ]

dds_3 <- DESeq(dds_2)
res_1 <- results(dds_3, contrast = c("condition","Treated","Control"))
summary(res_1)
sum(res_1$padj < 0.05, na.rm=TRUE)
dds_3 <- estimateSizeFactors(dds_3)
dds_3 <- estimateDispersions(dds_3)
plotDispEsts(dds_3)
dds_3 <- nbinomWaldTest(dds_3)



```
#Apply LFC shrinkage (for ranking)


```{r fig.width=11, fig.height=9, message=FALSE, warning=FALSE, echo=TRUE}

resLFC <- lfcShrink(dds_3,
                    coef = "condition_Treated_vs_Control",
                    type = "apeglm")
vsd <- vst(dds_3, blind = FALSE)
plotPCA(vsd, intgroup="condition") + ggtitle("PCA: Treated vs Control")

dist_mat <- dist(t(assay(vsd)))
pheatmap(as.matrix(dist_mat),
         clustering_distance_rows = dist_mat,
         clustering_distance_cols = dist_mat,
         main = "Sample distances")

EnhancedVolcano(resLFC,
                lab = rownames(resLFC),
                x = 'log2FoldChange',
                y = 'padj',
                title = 'Treated vs Control')

```


```{r fig.width=11, fig.height=9, message=FALSE, warning=FALSE, echo=TRUE}

library(ggplot2)
library(dplyr)
library(gridExtra)
library(RColorBrewer)

set.seed(123)

# Simulate RNA-seq data with batch effect and biological signal
n_genes <- 1000
n_samples <- 20

# Sample metadata
sample_info <- data.frame(
  sample_id = paste0("Sample_", 1:n_samples),
  treatment = rep(c("Control", "Treated"), each = 10),
  batch = rep(c("Batch_1", "Batch_2", "Batch_1", "Batch_2"), each = 5),
  stringsAsFactors = FALSE
)

# Generate base expression matrix
base_expression <- matrix(rnorm(n_genes * n_samples, mean = 8, sd = 2), 
                         nrow = n_genes, ncol = n_samples)

# Add strong batch effect (affects many genes with moderate effect size)
batch_effect_genes <- 1:800  # 80% of genes affected by batch
batch_multiplier <- ifelse(sample_info$batch == "Batch_1", 1.5, 0.7)
for(i in batch_effect_genes) {
  base_expression[i, ] <- base_expression[i, ] * batch_multiplier
}

# Add biological signal (affects fewer genes but with larger effect size)
treatment_effect_genes <- 1:200  # 20% of genes affected by treatment
treatment_multiplier <- ifelse(sample_info$treatment == "Treated", 2.2, 1.0)
for(i in treatment_effect_genes) {
  base_expression[i, ] <- base_expression[i, ] * treatment_multiplier
}

# Add noise
expression_matrix <- base_expression + matrix(rnorm(n_genes * n_samples, sd = 0.3), 
                                            nrow = n_genes, ncol = n_samples)

rownames(expression_matrix) <- paste0("Gene_", 1:n_genes)
colnames(expression_matrix) <- sample_info$sample_id

# PCA Analysis (using all genes)
pca_result <- prcomp(t(expression_matrix), scale. = TRUE)
pca_variance <- round(summary(pca_result)$importance[2,] * 100, 1)

pca_data <- data.frame(
  PC1 = pca_result$x[,1],
  PC2 = pca_result$x[,2],
  treatment = sample_info$treatment,
  batch = sample_info$batch,
  sample_id = sample_info$sample_id
)

# MDS Analysis (using top variable genes - simulating focus on DE genes)
# Calculate gene variance and select top variable genes
gene_var <- apply(expression_matrix, 1, var)
top_genes <- names(sort(gene_var, decreasing = TRUE))[1:200]  # Top 200 variable genes
mds_matrix <- expression_matrix[top_genes, ]

# Calculate distance matrix and perform MDS
dist_matrix <- dist(t(mds_matrix))
mds_result <- cmdscale(dist_matrix, k = 2)

mds_data <- data.frame(
  MDS1 = mds_result[,1],
  MDS2 = mds_result[,2],
  treatment = sample_info$treatment,
  batch = sample_info$batch,
  sample_id = sample_info$sample_id
)

# Create PCA plot
pca_plot <- ggplot(pca_data, aes(x = PC1, y = PC2)) +
  geom_point(aes(color = treatment, shape = batch), size = 4, alpha = 0.8) +
  scale_color_manual(values = c("Control" = "#E31A1C", "Treated" = "#1F78B4")) +
  scale_shape_manual(values = c("Batch_1" = 16, "Batch_2" = 17)) +
  labs(title = "PCA Plot",
       subtitle = "Shows batch effect dominating PC1",
       x = paste0("PC1 (", pca_variance[1], "% variance)"),
       y = paste0("PC2 (", pca_variance[2], "% variance)")) +
  theme_minimal() +
  theme(legend.position = "bottom",
        plot.title = element_text(size = 14, face = "bold")) +
  guides(color = guide_legend(title = "Treatment"),
         shape = guide_legend(title = "Batch"))

# Create MDS plot
mds_plot <- ggplot(mds_data, aes(x = MDS1, y = MDS2)) +
  geom_point(aes(color = treatment, shape = batch), size = 4, alpha = 0.8) +
  scale_color_manual(values = c("Control" = "#E31A1C", "Treated" = "#1F78B4")) +
  scale_shape_manual(values = c("Batch_1" = 16, "Batch_2" = 17)) +
  labs(title = "MDS Plot",
       subtitle = "Shows biological signal more clearly",
       x = "MDS Dimension 1",
       y = "MDS Dimension 2") +
  theme_minimal() +
  theme(legend.position = "bottom",
        plot.title = element_text(size = 14, face = "bold")) +
  guides(color = guide_legend(title = "Treatment"),
         shape = guide_legend(title = "Batch"))

# Display plots side by side
grid.arrange(pca_plot, mds_plot, ncol = 2, 
             top = "PCA vs MDS: Same Dataset, Different Insights")



```









