---
title: "RNA-Seq_differential_expression_analysis"
output: html_document
date: "2025-04-18"
---

```{r,packages}


suppressPackageStartupMessages({
  library("EnhancedVolcano")
  library("limma")
  library("tximport")
  library("apeglm")
  library("eulerr")
library("DESeq2")
  library("HGNChelper")
  library("tictoc")
  library("DESeq2")
  library("kableExtra")
  library("beeswarm")
  library("missMethyl")
  library("gridExtra")
  library("png")
  library("metafor")
  library("ggplot2")
  library("purrr")
library("metafor")
library("dplyr")
library("readxl")
library("ggplot2")
library("tidyverse")
library("magrittr")
library("readr")
library("eulerr")
library("RColorBrewer")
library("e1071")
  library("plotly") 
  library("pheatmap")

})

CORES=16

```
# Read the sample manifest and alignment summary

# Confirm all your pseudo-alignment rates are comfortably high (> ~90%).

```{r}
samples <- read_tsv("/mnt/vol1/RNA-Seq/kallisto_tutorial/results/samples.txt", col_types = cols())
samples

align <- read_tsv("/mnt/vol1/RNA-Seq/kallisto_tutorial/results/alignment_summary.tsv")
align %>% 
  dplyr::arrange(align$`Rate(%)`) %>% 
  print(n=10)

```

# Import transcripts to gene level via trimport package

```{r fig.width=11, fig.height=9, message=FALSE, warning=FALSE, echo=TRUE}

tx2gene <- read_tsv("/mnt/vol1/RNA-Seq/kallisto_tutorial/results/tx2gene.tsv",
                    col_names = c("TXNAME","GENEID"),
                    col_types = cols(
                      TXNAME = col_character(),
                      GENEID = col_character()
                    ))

head(tx2gene)

files <- samples$path
names(files) <- samples$sample

txi <- tximport(files    = files,
                type     = "kallisto",
                tx2gene  = tx2gene,
                ignoreTxVersion = TRUE)

# Inspect the components:
names(txi)

```

# Reading meta data that comes with the samples

```{r fig.width=11, fig.height=9, message=FALSE, warning=FALSE, echo=TRUE}

pheno<-read_delim("/mnt/vol1/RNA-Seq/SraRunTable.csv")
coldata <- pheno %>%
  select(sample = Run, condition = treatment) 

coldata <- coldata %>%
  mutate(condition = dplyr::recode(condition, 
                            "None" = "Control", 
                            "7day_UUO" = "Treated"))

samples <- left_join(samples, coldata, by = "sample")

```

# Making DESeqDataSet from tximport

```{r fig.width=11, fig.height=9, message=FALSE, warning=FALSE, echo=TRUE}

all(samples$sample == colnames(txi$counts))
samples <- samples[match(colnames(txi$counts), samples$sample), ]
head(samples)

metadata <- samples %>%
  column_to_rownames("sample") %>%
  select(condition) %>%
  tibble::rownames_to_column("run") %>%

# extract the last two digits of the run (e.g. "02") and build the new label
  mutate(
    label    = paste0(condition, "_SRR_")
  ) %>%
  tibble::column_to_rownames("run")
metadata$label

dds <- DESeqDataSetFromTximport(txi,
                                colData = metadata,
                                design  = ~ condition)
str(dds)

```


# Filtering for low count and normalisation of the counts

## Now that we have our DESeq2 object created with the raw counts and metadata stored inside, we can start the DESeq2 workflow. The first step in the workflow is to normalise the raw counts to assess sample-level quality control metrics.

## But what does it mean to normalise the raw counts? The raw counts represent the number of reads aligning to each gene and should be proportional to the expression of the RNA in the sample; however, there are factors other than RNA expression that can influence the number of reads aligning to each gene. We can adjust the count data to remove the influence of these factors on the overall counts using normalisation methods. The main factors often considered during normalisation of count data are library depth, gene length, and RNA composition.

## Differences in *library size* between samples can lead to many more reads being aligned to genes in one sample versus another sample. Another normalisation factor often adjusted for is *gene length*. A longer gene generates a longer transcript, which generates more fragments for sequencing. Therefore, a longer gene will often have more counts than a shorter gene with the same level of expression. If the DE analysis compares expression levels of the same genes between conditions, we do not need to normalise for gene length. However, if you were to compare the expression levels of different genes, you would need to account for lengths of the genes. For example In differential expression (DE) analysis:When comparing the expression of Gene A between Condition 1 and Condition 2, Gene A maintains the same physical length in both conditions. Since longer genes naturally attract more sequencing reads simply due to their increased target size, this length bias affects Gene A equally in both conditions. Therefore, when the ratio between conditions is calculated, the length bias cancels out mathematically, making gene length normalisation unnecessary.When comparing different genes: If comparing Gene A (1,000 base pairs) to Gene B (5,000 base pairs) within the same sample, Gene B will typically receive approximately five times more reads than Gene A, even if both genes are expressed at identical levels. This occurs because Gene B presents a larger target for random fragmentation and sequencing. Without length normalisation, Gene B would appear falsely more highly expressed.

## When adjusting for library size, the *composition of the library* is also important. A few highly differentially expressed genes can skew many normalisation methods that are not resistant to these outliers. If we just divided our counts by the total number of reads, normalisation for the majority of genes would be skewed by the highly expressed DE gene. For this reason, when performing a DE analysis, we need to use a method that is resistant to these outlier genes.


## DESeq2’s default *median-of-ratios* approach calculates a per-sample **size factor** that brings all libraries to a common scale.  
It corrects for library depth and remains robust even when many genes are truly differentially expressed..

## However, if you align your reads with Kallisto or Salmon and import them into R using tximport (with countsFromAbundance = "lengthScaledTPM" or "scaledTPM"), the resulting gene counts are already normalised for library depth (and, if requested, transcript length). In that case you can skip the explicit dds_1 <- estimateSizeFactors(dds) step and go straight to dds <- DESeq(dds). By contrast, when you use STAR (or any other method that produces raw integer counts), those counts have not been adjusted for library size, so you must run dds_1 <- estimateSizeFactors(dds) (or simply call DESeq(dds), which performs size‐factor estimation internally) before proceeding with differential expression analysis.

```{r fig.width=11, fig.height=9, message=FALSE, warning=FALSE, echo=TRUE}

keep <- rowSums(counts(dds)) >= 10
dds  <- dds[keep, ]

# size factors normalisation for the raw counts
normalizationFactors(dds)  # This will return NULL

#Seeing normalisationFactors(dds) return NULL simply means you have raw counts, you either need to call estimateSizeFactors(dds) (or DESeq(dds)), or if you prefer the tximport-driven approach, re-import with a countsFromAbundance= option so that DESeq2 can auto-generate those normalisation factors.

dds_1 <- estimateSizeFactors(dds)
head(normalizationFactors(dds_1))

#Extracts normalised count values from DESeq2 object after applying either size factors 
norm_counts<-counts(dds_1,normalized=TRUE)
head(norm_counts)

```


# Unsupervised clustering analyses

## With our counts normalised for library size, we can now compare the counts between the different samples. We can explore how similar the samples are to each other with regards to gene expression to assess the quality of our experiment. To do this we use visualisation methods for unsupervised clustering analyses, including hierarchical clustering heatmaps and principal component analysis or PCA. We perform these QC methods to get an idea of how similar the biological replicates are to each other and to identify outlier samples and major sources of variation present in the dataset.

## When using these visualisation methods, we should first log transform the normalised counts to improve the visualisation of the clustering. For RNA-Seq data, DESeq2 uses a variance stabilising transformation (VST), which is a logarithmic transformation that moderates the variance across the mean. We can transform the normalised counts by using the DESeq2 vst() function on the DESeq2 object. The blind=TRUE argument specifies that the transformation should be blind to the sample information given in the design formula; this argument should be specified when performing quality assessment.

## Hierarchical clustering with heatmaps is used to assess the similarity in gene expression between the different samples in a dataset. This technique is used to explore how similar replicates are to each other and whether the samples belonging to different sample groups cluster separately. The heatmap is created by using the gene expression correlation values for all pairwise combinations of samples in the dataset, with the value 1 being perfect correlation. Since the majority of genes should not be differentially expressed, samples should generally have high correlations with each other. Samples with correlation values below 0-point-8 may require further investigation to determine whether these samples are outliers or have contamination.We expect the biological replicates to cluster together and sample conditions to cluster apart.

## 

```{r fig.width=11, fig.height=9, message=FALSE, warning=FALSE, echo=TRUE}

vsd_dds1<-vst(dds_1,blind = TRUE)

# Creating hierarchical heatmap

## extract the vsd matrix form the object
vsd_mat<-assay(vsd_dds1)
  
## compute pairwise correlation values
vsd_cor<-cor(vsd_mat)
head(vsd_cor)

pheatmap(
  vsd_cor,
  labels_row     = metadata2$label,
  labels_col     = metadata2$label,
  annotation_col = metadata2["condition"],
  annotation_row = metadata2["condition"],
  fontsize       = 8,
  angle_col      = 45
)

# Creating PCA plots


dds_3 <- DESeq(dds_2)
res_1 <- results(dds_3, contrast = c("condition","Treated","Control"))
summary(res_1)
sum(res_1$padj < 0.05, na.rm=TRUE)
dds_3 <- estimateSizeFactors(dds_3)
dds_3 <- estimateDispersions(dds_3)
plotDispEsts(dds_3)
dds_3 <- nbinomWaldTest(dds_3)



```
#Apply LFC shrinkage (for ranking)


```{r fig.width=11, fig.height=9, message=FALSE, warning=FALSE, echo=TRUE}

resLFC <- lfcShrink(dds_3,
                    coef = "condition_Treated_vs_Control",
                    type = "apeglm")
vsd <- vst(dds_3, blind = FALSE)
plotPCA(vsd, intgroup="condition") + ggtitle("PCA: Treated vs Control")

dist_mat <- dist(t(assay(vsd)))
pheatmap(as.matrix(dist_mat),
         clustering_distance_rows = dist_mat,
         clustering_distance_cols = dist_mat,
         main = "Sample distances")

EnhancedVolcano(resLFC,
                lab = rownames(resLFC),
                x = 'log2FoldChange',
                y = 'padj',
                title = 'Treated vs Control')

```


```{r fig.width=11, fig.height=9, message=FALSE, warning=FALSE, echo=TRUE}

library(ggplot2)
library(dplyr)
library(gridExtra)
library(RColorBrewer)

set.seed(123)

# Simulate RNA-seq data with batch effect and biological signal
n_genes <- 1000
n_samples <- 20

# Sample metadata
sample_info <- data.frame(
  sample_id = paste0("Sample_", 1:n_samples),
  treatment = rep(c("Control", "Treated"), each = 10),
  batch = rep(c("Batch_1", "Batch_2", "Batch_1", "Batch_2"), each = 5),
  stringsAsFactors = FALSE
)

# Generate base expression matrix
base_expression <- matrix(rnorm(n_genes * n_samples, mean = 8, sd = 2), 
                         nrow = n_genes, ncol = n_samples)

# Add strong batch effect (affects many genes with moderate effect size)
batch_effect_genes <- 1:800  # 80% of genes affected by batch
batch_multiplier <- ifelse(sample_info$batch == "Batch_1", 1.5, 0.7)
for(i in batch_effect_genes) {
  base_expression[i, ] <- base_expression[i, ] * batch_multiplier
}

# Add biological signal (affects fewer genes but with larger effect size)
treatment_effect_genes <- 1:200  # 20% of genes affected by treatment
treatment_multiplier <- ifelse(sample_info$treatment == "Treated", 2.2, 1.0)
for(i in treatment_effect_genes) {
  base_expression[i, ] <- base_expression[i, ] * treatment_multiplier
}

# Add noise
expression_matrix <- base_expression + matrix(rnorm(n_genes * n_samples, sd = 0.3), 
                                            nrow = n_genes, ncol = n_samples)

rownames(expression_matrix) <- paste0("Gene_", 1:n_genes)
colnames(expression_matrix) <- sample_info$sample_id

# PCA Analysis (using all genes)
pca_result <- prcomp(t(expression_matrix), scale. = TRUE)
pca_variance <- round(summary(pca_result)$importance[2,] * 100, 1)

pca_data <- data.frame(
  PC1 = pca_result$x[,1],
  PC2 = pca_result$x[,2],
  treatment = sample_info$treatment,
  batch = sample_info$batch,
  sample_id = sample_info$sample_id
)

# MDS Analysis (using top variable genes - simulating focus on DE genes)
# Calculate gene variance and select top variable genes
gene_var <- apply(expression_matrix, 1, var)
top_genes <- names(sort(gene_var, decreasing = TRUE))[1:200]  # Top 200 variable genes
mds_matrix <- expression_matrix[top_genes, ]

# Calculate distance matrix and perform MDS
dist_matrix <- dist(t(mds_matrix))
mds_result <- cmdscale(dist_matrix, k = 2)

mds_data <- data.frame(
  MDS1 = mds_result[,1],
  MDS2 = mds_result[,2],
  treatment = sample_info$treatment,
  batch = sample_info$batch,
  sample_id = sample_info$sample_id
)

# Create PCA plot
pca_plot <- ggplot(pca_data, aes(x = PC1, y = PC2)) +
  geom_point(aes(color = treatment, shape = batch), size = 4, alpha = 0.8) +
  scale_color_manual(values = c("Control" = "#E31A1C", "Treated" = "#1F78B4")) +
  scale_shape_manual(values = c("Batch_1" = 16, "Batch_2" = 17)) +
  labs(title = "PCA Plot",
       subtitle = "Shows batch effect dominating PC1",
       x = paste0("PC1 (", pca_variance[1], "% variance)"),
       y = paste0("PC2 (", pca_variance[2], "% variance)")) +
  theme_minimal() +
  theme(legend.position = "bottom",
        plot.title = element_text(size = 14, face = "bold")) +
  guides(color = guide_legend(title = "Treatment"),
         shape = guide_legend(title = "Batch"))

# Create MDS plot
mds_plot <- ggplot(mds_data, aes(x = MDS1, y = MDS2)) +
  geom_point(aes(color = treatment, shape = batch), size = 4, alpha = 0.8) +
  scale_color_manual(values = c("Control" = "#E31A1C", "Treated" = "#1F78B4")) +
  scale_shape_manual(values = c("Batch_1" = 16, "Batch_2" = 17)) +
  labs(title = "MDS Plot",
       subtitle = "Shows biological signal more clearly",
       x = "MDS Dimension 1",
       y = "MDS Dimension 2") +
  theme_minimal() +
  theme(legend.position = "bottom",
        plot.title = element_text(size = 14, face = "bold")) +
  guides(color = guide_legend(title = "Treatment"),
         shape = guide_legend(title = "Batch"))

# Display plots side by side
grid.arrange(pca_plot, mds_plot, ncol = 2, 
             top = "PCA vs MDS: Same Dataset, Different Insights")



```









